
; comment
# also comment

# defition of identity
id = \x -> x

# lambda calculus booleans
true = \a -> \b -> a
false = \a -> \b -> b

# To be able to see anything
# Bindings that begin with $ are custom expressions. They can produce side effects!
assert = \b -> b $print_true $print_false

# This returns $print_true and evaluates it
assert true
# This will print false
not = \b -> b false true
assert (not true)

# Bindings can have almost any name
你好，世界 = id

# Pair. Notice that redundant \ -> can be skipped
pair = \a b f -> f a b
fst = \p -> p true
snd = \p -> p false

# One possibility to define natural numbers
0 = pair true id
1 = suc 0
2 = suc 1
3 = suc 2
4 = suc 3
5 = suc 4
6 = suc (suc (suc (suc (suc (suc 0)))))
# This will act as infinity
inf = suc inf

# Is inf 0? No, it's infinite recursion
is0 = \n -> fst n
is1 = \n -> is0 (pred n)

# Successor and predcessor. Notice we used it above, that is ok
suc  = \n -> pair false n
pred = \n -> snd n

# In fact, this is also valid:
x1 = id x2
x2 = id x3
x3 = x1
# But these are not:
# y1 = y2
# y2 = y1
# 
# w = w
#
# a = k    # 'k' needs to be defined first
# k = id

printnat 5

evaln = \c -> \n -> (is0 n) c (evaln (c c) (pred n))
printnat = evaln $ec
