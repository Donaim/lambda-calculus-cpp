
; comment
# also comment

# defition of identity
id = \x -> x

; # lambda calculus booleans
; true = \a -> \b -> a
; false = \a -> \b -> b

; # To be able to see anything. Bindings that begin with $ are predefined
; # (can produce side effects)
; assert = \b -> b $print_true $print_false

; # This returns $print_true and evaluates it
; assert true
; # This will print false
; not = \b -> b false true
; assert (not true)

; $add ($ec $ec) ($ec)

; # Bindings can have almost any name
; 你好，世界 = id

; # Pair. Notice that redundant \ -> can be skipped
; pair = \a b f -> f a b
; fst = \p -> p true
; snd = \p -> p false

; # One possibility to define natural numbers
; 0 = pair true id
; 1 = suc 0
; 2 = suc 1
; 3 = suc 2
; 4 = suc 3
; 5 = suc 4
; 6 = suc (suc (suc (suc (suc (suc 0)))))
; # This will act as infinity
; inf = suc inf

; # Is inf 0? No, it's infinite recursion
; is0 = \n -> fst n
; is1 = \n -> is0 (pred n)

; # Successor and predcessor. Notice we used it above, that is ok
; suc  = \n -> pair false n
; pred = \n -> snd n

# In fact, this is also valid:
x1 = id x2
x2 = id x3
x3 = x1
; # But these are not:
; # y1 = y2
; # y2 = y1
; # 
; # w = w
; #
; # a = k    # 'k' needs to be defined first
; # k = id

; # This is to print numbers
; # I use predefined EvaluationCounter ($ec) to do that
; evaln = \c -> \n -> (is0 n) c (evaln (c c) (pred n))
; printnat = evaln $ec

; applyn = \f x n -> (is0 n) x (applyn f (f x) (pred n))

; 9 = applyn (+ 3) 0 3
; printnat 9

; >= = \a b -> (is0 a) (is0 b) ((is0 b) true (>= (pred a) (pred b)))

; + = \a b -> (is0 a) b (suc (+ (pred a) b))

; # Recursive Fibonacci takes a lot of time
; # But if cache is enable, it becomes much better
; fib = \n -> (is0 n) 0 ((is1 n) 1 (+ (fib (pred n)) (fib (pred (pred n)))))

; printnat (fib (* 6 2)) # fib(12) = 144

; * = \a b -> (is1 a) b (+ b (* (pred a) b))

; # Y-combinator, allows to use recursion without bindings
; Y = (\f -> (\x -> x x) (\x -> f (x x)))

; # Example usage of Y
; facY = Y (\f n ->
; 	(is0 n)                 # Stopping condition
; 		1
; 		(* n (f (pred n)))) # Recursive call

; printnat (facY 5) # = 120

; # $facc is predefined, much faster
; $facc (printnat (* 5 2)) # 10! = 3628800
