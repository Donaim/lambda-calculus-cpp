; comment
# also comment

# defition of identity
id = \x -> x

# lambda calculus booleans
true = \a -> \b -> a
false = \a -> \b -> b

# To be able to see anything. Bindings that begin with $ are predefined
# (can produce side effects)
assert = \b -> b $print_true $print_false

# This returns $print_true and evaluates it
assert true
# This will print false
not = \b -> b false true
assert (not true)

# Pair. Notice that redundant \ -> can be skipped
pair = \a b f -> f a b
fst = \p -> p true
snd = \p -> p false

# One possibility to define natural numbers
0 = pair true id
1 = suc 0
2 = suc 1
3 = suc 2
4 = suc 3
5 = suc 4
6 = suc (suc (suc (suc (suc (suc 0)))))
7 = suc 6
# This will act as infinity
inf = suc inf

# Is inf 0? No, it's infinite recursion
is0 = \n -> fst n
is1 = \n -> is0 (pred n)

# Successor and predcessor. Notice we used it above, that is ok
suc  = \n -> pair false n
pred = \n -> snd n

# This is to print numbers
# I use predefined EvaluationCounter ($ec) to do that
evaln = \c -> \n -> (is0 n) c (evaln (c c) (pred n))
printnat = evaln $ec

applyn = \f x n -> (is0 n) x (applyn f (f x) (pred n))

+ = \a b -> (is0 a) b (suc (+ (pred a) b))
* = \a b -> (is1 a) b (+ b (* (pred a) b))

9 = applyn (+ 3) 0 3
printnat 9

# $facc is predefined, much faster
$facc (printnat (* 5 2)) # 10! = 3628800

; $pmint (applyn ($mult ($msuc ($msuc $mint))) ($msuc $mint) 4)

; $pmint ($pow ($msuc ($msuc)))

pp ($add ($msuc ($msuc $mint)) $mint)

pp = \n f -> $pmint n


# Recursive Fibonacci takes a lot of time
# But if cache is enable, it becomes much better
fib = \n -> (is0 n) 0 ((is1 n) 1 (+ (fib (pred n)) (fib (pred (pred n)))))

printnat (fib 5) # fib(5) = 5
printnat (fib 6) # fib(6) = 8
printnat (fib 7) # fib(7) = 13

